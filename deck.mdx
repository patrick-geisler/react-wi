export { default as theme } from './theme'

# Whats New in 16.6??

A talk by [@patrick-geisler]() and [@caryyon]() given at the [MKE-Reactjs-Meetup](https://www.meetup.com/ReactJS-Wisconsin/).

---

## Main Topics

* `React.memo()`
* `React.lazy()`
* `static contextType()`
* `static getDerivedStateFromError()`
* A few Deprecations

---

## React.memo()

`React.memo()` is a HOC  that can be wrapped around any functional component to create 'memoized' components. 

```notes
The wrapped component will only rerender when it's props change. 

Similar to  class(stateful) lifecycle method `shouldComponentUpdate()`

A component that renders the same given the same props to be stored in memory. 

This allows the component to skip being rerendered will simply reuse the last rendered result of the component.

```
---

## React.memo() Example
```javascript

class App extends Component {
  // Set State
  // Handle Click count++
  render() {
    return (
      <div className="App">
        <div>
          {this.state.count}
        </div>
        <button onClick={this.handleClick}>
            Counter++
        </ button>
        <AnotherComponent text={'Title'}/>
      </div>
    );
  }
}

```

---

## React.memo() Example
```javascript

import React, { memo } from 'react'

const AnotherComponent = ({ text }) => {
  console.log('AnotherComponent is rendering')
  return(
    <div>
      { text }
    </ div>
  )
}

export default memo(AnotherComponent)

```
---

# React.memo() Example

---

## Custom Comparisons

```javascript 
import React, { memo } from 'react'

// Stateless Funcitonal Component
const AnotherComponent = props => {}

const areEqual = (prevProps, nextProps) => {}
  /*
  return true if passing nextProps to render would return
  the same result as passing prevProps to render,
  otherwise return false
  */

export default memo(AnotherComponent, areEqual)

```


---

## Custom Comparisons

This method only exists as a `performance optimization`. Do not rely on it to prevent a render.



---

## React.lazy()

`React.lazy()` is a way to render a dynamically imported component.

---

## React.Suspense

`React.Suspense` let you specify the loading indicator in case some components in the tree below it are not yet ready to render.

---
## React.Suspense

Rendering lazy components requires that there’s a `<React.Suspense>` component higher in the rendering tree.
---

## React.lazy() Example

```javascript
import React, { lazy, Suspense } from 'react'
```

```notes
Destructure lazy and Suspense from react
```
---

## React.lazy() Before
```javascript

import Component from './Component'

const NewComp = () => {
    return (
        <React.Fragment>
            <Component />
        </React.Fragment>
    )
}
```
```notes
Normal import of component
Normal use of component in parent.
```
---
## React.lazy() After

```javascript
const Component = lazy(() => import('./Component'))

const NewComp = () => {
    return (
        <React.Suspense fallback={<Loader />}>
            <Component />
        </React.Suspense>
    )
}


```

---

## static contextType()

Convenience API to consume a context value from within a class component.

---
## static contextType()

```javascript
import { MyContext } from './MyContext'

class UseContext extends Component {
  static contextType = MyContext
  componentDidMount(){
    let value = this.context
    // Do something at mount using MyContext
  }
  render(){
    let value = this.context
    // Render something based on MyContext
  }
}

```

---

## Static getDerivedStateFromError()

---

## Deprecations

---

## Why Hooks?

---

## Why Hooks?

- Very large components
- Complicated component tree
- Classes can be confusing
- No smaller way to introduce state than class components

```notes
 - Large components are hard to refactor
 - Splitting up components can create tons of wrapping and complexity in the component tree
 - Binding, this, and consyructors can be confusing
```

---

## Use State Hook

---

## use Effect Hook
- Perform side effects in function components

- useEffect() runs both on initial render and on subsequent updates

```notes
- Think of it as componentDidMount, componentDidUpdate, and componentWillUnmount combined
- Can be altered for performance
- Effect can return a function to clean up and unsubscribe
```

---

### use Effect Hook

``` js
useEffect(() => {
    window.newrelic.setCustomAttribute(
      'clientID', window.__STATE__.meta.clientID
    )
``` 

```notes
Running additional code after React updates DOM
Logging/Analytics
```
---

## use Effect Hook

Cleaning up an Effect Hook

---

## use Effect Hook

Old way:

```js
componentDidMount(){
  Client.subscribeToClientStatus(clientID, handleStatusChange)
}

componentWillUnmount(){
  Client.unsubscribeFromClientStatus(clientID, handleStatusChange);
}

```

```notes
- Avoid writing mirrored code in seperate lifecycle methods
```

---

## use Effect Hook

With Hooks:
``` js
useEffect(() => {
    Client.subscribeToClientStatus(clientID, handleStatusChange);
    // Specify how to clean up after this effect:
    return function cleanup() {
      Client.unsubscribeFromClientStatus(clientID, handleStatusChange);
    };
  });
``` 
```notes
- React performs the cleanup() when the component unmounts. However effects run for every render and not just once. 
- Don’t have to  return named function
- React also cleans up effects from the previous render before running the effects next time.
```
---
## Custom Hooks

```notes
Extract component logic into reusable functions
```

---
## Custom Hooks
CARY: DO THAT ZOOMY THING ON COMPONET AND HOOK
      PLEASE DOUBLE CHECK THIS PLEASE
      ITS PROBABLY WRONG AND MY EGO CANT TAKE IT
      
HOOK
``` js
import React, { useState, useEffect } from 'react';

function useClientStatus((clinetID) => {
  const [isOnline, setIsOnline] = useState(null);

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }

  useEffect(() => {
    Client.subscribeToClientStatus(clinetID, handleStatusChange);
    return () => {
      Client.unsubscribeFromClientStatus(clinetID, handleStatusChange);
    };
  });

  return isOnline;
  });
``` 

COMPONENT
``` js
const clientStatus = ({ clientName }) => {
	const [clientStatus, changeClientStatus] = useClientStatus(clientID)

  const clientStatusColor = () => {
    if(clientStatus === 'Online'){
      return 'Green'
    } else {
      return 'Red'
    }
  }
		return(
		<React.Fragment>
			<StatusIcon fill={clientStatusColor(clientStatus)}>
			{ClientName}
		</React.Fragment>
		)
	
}
``` 

---

# Custom Hooks

Do I have to name my custom Hooks starting with “use”?

---


# Custom Hooks

Yes
(but not really)


```notes
This convention is very important. 
Without it, we wouldn’t be able to automatically 
check for violations of rules of Hooks because we couldn’t 
tell if a certain function contains calls to Hooks inside of it.

```
---

# References 
- [Introducing Hooks – React](https://reactjs.org/docs/hooks-intro.html)
- [Using the State Hook – React](https://reactjs.org/docs/hooks-state.html)
- [Using the Effect Hook – React](https://reactjs.org/docs/hooks-effect.html#tip-use-multiple-effects-to-separate-concerns)
- [How Node.js is Going to Replace JavaScript – Medium](https://medium.com/cool-code-pal/how-node-js-is-going-to-replace-javascript-cf72b588b1b)

---

# Slides
- [Slides](https://github.com/patrick-geisler/react-wi)
- [Demo] (https://github.com/patrick-geisler/reactjs-wi-demo)

---

# Questions?

---

# Thank You!
